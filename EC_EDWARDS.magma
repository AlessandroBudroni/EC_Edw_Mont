// Set of function to handle simple operations on elliptic curve in Edwards form

// Print a point P as (a,b)
printPointxy := function(P)

	Qx := Sprintf("%h",Integers()!P[1]);
	Qx:=Qx[3..#Qx];

	Qy := Sprintf("%h",Integers()!P[2]);
	Qy:=Qy[3..#Qy];

	if (#Qx mod 2 eq 1) then
		Qx := "0" cat Qx;
	end if;

	if (#Qy mod 2 eq 1) then
		Qy := "0" cat Qy;
	end if;

	printf "(%o,%o)\n",Qx,Qy;
	return 0;
end function;

// Compute right side of the equation y^2 = (Ax^2-1)/(dx^2-1), p is the order of the field.
EdwardsRHS := function (A,d,p)
	F:=GF(p);
	return (F!(A*P^2-1))*((F!(d*P^2-1))^(-1));
end function;

// Get a randon point (slow, not generator known) of the curve with parameters A,d. p is the order of the field.
RandEdwardsPoint := function(A,d,p)
	
	F:=GF(p);
	j:=2;
	P:=Random(F);
	j:=Integers()!( EdwardsRHS(P,A,d,p) );
	while(JacobiSymbol(j,p) ne 1) do
		P:=Random(F);
		j:=Integers()!( EdwardsRHS(P,A,d,p) );
	end while;

	return [F!P,F!Sqrt(EdwardsRHS(P,A,d,p)),F!1];

end function;

// (x,y,z) -> (x/z,y/z,1)
EdwAffine := function(X,p)

	Z := Modinv(Integers()!X[3],p);
	X[1] := X[1]*Z;
	X[2] := X[2]*Z;
	X[3] := X[3]*Z;
	return X;

end function;

// given two points X,Y, return X+Y
EdwAdd := function(X,Y,A,d,p)

	F := GF(p);
	R := [F!0,F!0,F!0];

	a := X[3]*Y[3];
	b := a^2;
	c := X[1]*Y[1];
	d := X[2]*Y[2];
	e := d*c*d;
	f := b-e;
	g := b+e;
	R[1] := f*a*((X[1]+X[2])*(Y[1]+Y[2])-c-d);
    R[2] := a*g*(d-A*c);
    R[3] := f*g;

    return EdwAffine(R,p);

end function;

// Given a point X, return 2X
EdwDbl := function(X,A,p)

	F:=GF(p);
	R := [F!0,F!0,F!0];

	b := (X[1]+X[2])^2;
	c := X[1]^2;
	d := X[2]^2;
	e := A*c;
	f := e+d;
	h := X[3]^2;
	j := f-2*h;
	R[1] := (b-c-d)*j;
	R[2] := f*(e-d);
	R[3] := f*j;

	return EdwAffine(R,p);
end function;

// Given a point X, return -X
EdwNeg := function(X,p)
	
	F:=GF(p);
	X[1] := F!(-X[1]);
	return X;
end function;

// given two points X,Y, return X-Y
EdwSub := function(X,Y,A,d,p)
	
	F:=GF(p);
	Y := EdwNeg(Y,p);
	return EdwAdd(X,Y,A,d,p);
end function;

// given a point P and a scalar n return nP
EdwMul := function(P,n,A,d,p)

	d := Intseq(n,2);

	F := GF(p);

	N := P;
	Q := [F!0,F!1,F!1];

	for i in [1..#d] do
		if d[i] eq 1 then
			Q := EdwAdd(Q,N,A,d,p);
		end if;
		N := EdwDbl(N,A,p);
	end for;
	return Q;

end function;

test_EDW := function()

	p:= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed; 
	A:= -1; 
	d:= 0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3;

	P := RandEdwardsPoint(A,d,p);
	Q := EdwDbl();
	R := EdwAdd();
	S := EdwMul();
	R := EdwAffine();
	S := EdwAffine();
	if R eq S then
		print "test passed"
		return 0;
	else
		return -1;
	endif;

end function;